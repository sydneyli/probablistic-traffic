var otherPlayer = function(player) {
  return (player === "car" ? "ped" : "car");
};

var movePrior =  function(state, player) {
  if (player === "car") {
    return carPrior(state);
  } else {
    return pedPrior(state);
  }
};

var utility = function(state, player) {
  if (player == "car") {
    if (crashed(state)) {
      return carCrashReward;
    } else if (state.carCrossTime != -1) {
      return carReward(state);
    } else {
      return -carTimeCost*state.time;
    }
  } else {
    if (crashed(state)) {
      return pedCrashReward;
    } else if (state.pedCrossTime != -1) {
      return pedReward(state);
    } else {
      return -pedTimeCost*state.time;
    }
  }
};

var guessState = function(state, player) {
  if (player === "car") {
    return guessPedState(state);
  } else {
    return guessCarState(state);
  }
};

var getMoves = function(state, player, mentalDepth, futureDepth) {
    var move = sample(movePrior(state, player));
    var other = otherPlayer(player);
    var othersMove = sample(actMine(state, other, mentalDepth-1, futureDepth, false));
    var moves = (player === "ped" ? {ped:move, car:othersMove} : {ped:othersMove, car:move});
    return moves;
};

var actMine = function(state, player, mentalDepth, futureDepth, addNoise) {
  return Infer({method: "enumerate", maxExecutions: actExecutions, model() {
    if (mentalDepth === 0) {
      return sample(movePrior(state, player));
    } else {
      var guessedState = addNoise ? guessState(state, player) : state;
      var moves = getMoves(guessedState, player, mentalDepth, futureDepth);
      var eu = expectation(Infer({method: "enumerate", maxExecutions: simulateExecutions, model() {
        var outcome = mentalSimulate(state, moves, player, mentalDepth, futureDepth-1);
        return utility(outcome, player);
      }}));
      if(addNoise) {
        factor(1000*eu);
      } else {
        factor(eu);
      }
      return player === "car" ? moves.car : moves.ped;
    }
  }});
};

var actBoth = function(state, player, mentalDepth, futureDepth, addNoise) {
  return Infer({method: "enumerate", maxExecutions: actExecutions, model() {
    if (mentalDepth === 0) {
      return sample(movePrior(state, player));
    } else {
      var guessedState = addNoise ? guessState(state, player) : state;
      var moves = getMoves(guessedState, player, mentalDepth, futureDepth);
      var eu = expectation(Infer({method: "enumerate", maxExecutions: simulateExecutions, model() {
        var outcome = mentalSimulate(state, moves, player, mentalDepth, futureDepth-1);
        return utility(outcome, player);
      }}));
      factor(1000*eu);
      return moves;
    }
  }});
};

var mentalSimulate = function(state, moves, player, mentalDepth, futureDepth) {
  var nextState = transition(state, moves);
  if (isTerminal(nextState) || futureDepth === 0) {
    return nextState;
  } else {
    var newMoves = sample(actBoth(nextState, player, mentalDepth, futureDepth, false));
    return mentalSimulate(nextState, newMoves, player, mentalDepth, futureDepth-1);
  }
};

var realSimulate = function(state, states) {
  states.push(state);
  if (!isTerminal(state)) {
    var pedMove = sample(actMine(state, "ped", iMentalDepth, iFutureDepth, true));
    var carMove = sample(actMine(state, "car", iMentalDepth, iFutureDepth, true));
    var moves = { ped: pedMove, car: carMove };
    var newState = transition(state, moves);
    realSimulate(newState, states);
  }
};
